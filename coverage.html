
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">httpsserver/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">httpsserver/config.go (0.0%)</option>
				
				<option value="file2">httpsserver/internal/auth/auth.go (100.0%)</option>
				
				<option value="file3">httpsserver/internal/config/config.go (100.0%)</option>
				
				<option value="file4">httpsserver/internal/database/database.go (8.8%)</option>
				
				<option value="file5">httpsserver/internal/handler/handler.go (0.0%)</option>
				
				<option value="file6">httpsserver/internal/utils/cert.go (60.0%)</option>
				
				<option value="file7">httpsserver/main.go (0.0%)</option>
				
				<option value="file8">httpsserver/pkg/response/response.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "log"

        "github.com/gin-gonic/gin"

        "httpsserver/internal/auth"
        "httpsserver/internal/config"
        "httpsserver/internal/database"
        "httpsserver/internal/handler"
        "httpsserver/internal/utils"
)

func main() <span class="cov0" title="0">{
        // åŠ è½½é…ç½®
        cfg := config.Load()

        // åˆå§‹åŒ–æ•°æ®åº“è¿æ¥
        db, err := database.New(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥:", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // åˆå§‹åŒ–è®¤è¯æœåŠ¡
        authSvc := auth.New(cfg)

        // åˆå§‹åŒ–å¤„ç†å™¨
        h := handler.New(db, authSvc)

        // è®¾ç½®Ginä¸ºå‘å¸ƒæ¨¡å¼
        gin.SetMode(gin.ReleaseMode)

        // åˆ›å»ºGinå¼•æ“
        r := gin.Default()

        // æ·»åŠ è¯·æ±‚æ—¥å¿—è®°å½•ä¸­é—´ä»¶
        r.Use(gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string </span><span class="cov0" title="0">{
                return fmt.Sprintf("[%s] %s \"%s %s %s\" %d %s \"%s\" \"%s\" %d\n",
                        param.TimeStamp.Format("2006/01/02 - 15:04:05"),
                        param.ClientIP,
                        param.Method,
                        param.Path,
                        param.Request.Proto,
                        param.StatusCode,
                        param.Latency,
                        param.Request.UserAgent(),
                        param.ErrorMessage,
                        param.BodySize,
                )
        }</span>))

        // æ·»åŠ CORSä¸­é—´ä»¶
        <span class="cov0" title="0">r.Use(func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("Access-Control-Allow-Origin", "*")
                c.Header("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE")
                c.Header("Access-Control-Allow-Headers", "Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        })

        // å®šä¹‰è·¯ç”±
        <span class="cov0" title="0">r.POST("/service/:serviceId", h.HandleServiceRequest)

        // ç”Ÿæˆè‡ªç­¾åè¯ä¹¦ï¼ˆä»…ç”¨äºå¼€å‘æµ‹è¯•ï¼‰
        utils.GenerateSelfSignedCert(cfg.Server.CertFile, cfg.Server.KeyFile)

        // å¯åŠ¨HTTPSæœåŠ¡å™¨
        log.Printf("HTTPSæœåŠ¡å™¨å¯åŠ¨åœ¨ç«¯å£%s...", cfg.Server.Port)
        log.Fatal(r.RunTLS(":"+cfg.Server.Port, cfg.Server.CertFile, cfg.Server.KeyFile))</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "os"
)

// é…ç½®ç»“æ„ä½“
type Config struct {
        // æ•°æ®åº“é…ç½®
        DB struct {
                Host     string
                Port     string
                User     string
                Password string
                Database string
                Charset  string
        }

        // æœåŠ¡å™¨é…ç½®
        Server struct {
                Port     string
                CertFile string
                KeyFile  string
        }

        // è®¤è¯é…ç½®
        Auth struct {
                ClientID     string
                ClientSecret string
        }
}

// è·å–é…ç½®
func getConfig() *Config <span class="cov0" title="0">{
        config := &amp;Config{}

        // æ•°æ®åº“é…ç½®ï¼ˆæ”¯æŒç¯å¢ƒå˜é‡ï¼‰
        config.DB.Host = getEnv("DB_HOST", "localhost")
        config.DB.Port = getEnv("DB_PORT", "3306")
        config.DB.User = getEnv("DB_USER", "root")
        config.DB.Password = getEnv("DB_PASSWORD", "")
        config.DB.Database = getEnv("DB_DATABASE", "metadata_db")
        config.DB.Charset = getEnv("DB_CHARSET", "utf8mb4")

        // æœåŠ¡å™¨é…ç½®
        config.Server.Port = getEnv("SERVER_PORT", "18443")
        config.Server.CertFile = getEnv("SSL_CERT_FILE", "server.crt")
        config.Server.KeyFile = getEnv("SSL_KEY_FILE", "server.key")

        // è®¤è¯é…ç½®
        config.Auth.ClientID = getEnv("CLIENT_ID", "eplat")
        config.Auth.ClientSecret = getEnv("CLIENT_SECRET", "eplat2019111214440")

        return config
}</span>

// è·å–ç¯å¢ƒå˜é‡ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å›é»˜è®¤å€¼
func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// æ„å»ºæ•°æ®åº“è¿æ¥å­—ç¬¦ä¸²
func (c *Config) GetDSN() string <span class="cov0" title="0">{
        return c.DB.User + ":" + c.DB.Password + "@tcp(" + c.DB.Host + ":" + c.DB.Port + ")/" + c.DB.Database + "?charset=" + c.DB.Charset + "&amp;parseTime=True&amp;loc=Local"
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package auth

import (
        "log"

        "httpsserver/internal/config"
        "httpsserver/internal/model"
)

// Service è®¤è¯æœåŠ¡
type Service struct {
        cfg *config.Config
}

// New åˆ›å»ºæ–°çš„è®¤è¯æœåŠ¡
func New(cfg *config.Config) *Service <span class="cov8" title="1">{
        return &amp;Service{
                cfg: cfg,
        }
}</span>

// Authenticate éªŒè¯å®¢æˆ·ç«¯è®¤è¯ä¿¡æ¯
func (s *Service) Authenticate(req model.ServiceRequest) bool <span class="cov8" title="1">{
        // è®°å½•è®¤è¯å°è¯•
        log.Printf("ğŸ” è®¤è¯è¯·æ±‚ - ClientID: %s, UserID: %s", req.ClientID, req.UserID)

        // éªŒè¯å®¢æˆ·ç«¯ä¿¡æ¯
        if req.ClientID != s.cfg.Auth.ClientID || req.ClientSecret != s.cfg.Auth.ClientSecret </span><span class="cov8" title="1">{
                log.Printf("ğŸš« å®¢æˆ·ç«¯è®¤è¯å¤±è´¥ - æœŸæœ›ClientID: %s, å®é™…ClientID: %s", s.cfg.Auth.ClientID, req.ClientID)
                return false
        }</span>

        <span class="cov8" title="1">log.Printf("âœ… å®¢æˆ·ç«¯è®¤è¯æˆåŠŸ - UserID: %s", req.UserID)
        return true</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "os"
)

// Config åº”ç”¨é…ç½®ç»“æ„ä½“
type Config struct {
        // æ•°æ®åº“é…ç½®
        DB struct {
                Host     string
                Port     string
                User     string
                Password string
                Database string
                Charset  string
        }

        // æœåŠ¡å™¨é…ç½®
        Server struct {
                Port     string
                CertFile string
                KeyFile  string
        }

        // è®¤è¯é…ç½®
        Auth struct {
                ClientID     string
                ClientSecret string
        }
}

// Load åŠ è½½é…ç½®
func Load() *Config <span class="cov8" title="1">{
        config := &amp;Config{}

        // æ•°æ®åº“é…ç½®ï¼ˆæ”¯æŒç¯å¢ƒå˜é‡ï¼‰
        config.DB.Host = getEnv("DB_HOST", "localhost")
        config.DB.Port = getEnv("DB_PORT", "3306")
        config.DB.User = getEnv("DB_USER", "root")
        config.DB.Password = getEnv("DB_PASSWORD", "")
        config.DB.Database = getEnv("DB_DATABASE", "metadata_db")
        config.DB.Charset = getEnv("DB_CHARSET", "utf8mb4")

        // æœåŠ¡å™¨é…ç½®
        config.Server.Port = getEnv("SERVER_PORT", "18443")
        config.Server.CertFile = getEnv("SSL_CERT_FILE", "server.crt")
        config.Server.KeyFile = getEnv("SSL_KEY_FILE", "server.key")

        // è®¤è¯é…ç½®
        config.Auth.ClientID = getEnv("CLIENT_ID", "eplat")
        config.Auth.ClientSecret = getEnv("CLIENT_SECRET", "eplat2019111214440")

        return config
}</span>

// GetDSN æ„å»ºæ•°æ®åº“è¿æ¥å­—ç¬¦ä¸²
func (c *Config) GetDSN() string <span class="cov8" title="1">{
        return c.DB.User + ":" + c.DB.Password + "@tcp(" + c.DB.Host + ":" + c.DB.Port + ")/" + c.DB.Database + "?charset=" + c.DB.Charset + "&amp;parseTime=True&amp;loc=Local"
}</span>

// getEnv è·å–ç¯å¢ƒå˜é‡ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å›é»˜è®¤å€¼
func getEnv(key, defaultValue string) string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "log"

        _ "github.com/go-sql-driver/mysql"

        "httpsserver/internal/config"
        "httpsserver/internal/model"
)

// DB æ•°æ®åº“è¿æ¥å®ä¾‹
type DB struct {
        conn *sql.DB
}

// New åˆ›å»ºæ–°çš„æ•°æ®åº“è¿æ¥
func New(cfg *config.Config) (*DB, error) <span class="cov8" title="1">{
        // è¿æ¥MySQLæ•°æ®åº“
        dsn := cfg.GetDSN()
        conn, err := sql.Open("mysql", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("æ•°æ®åº“è¿æ¥å¤±è´¥: %w", err)
        }</span>

        // æµ‹è¯•æ•°æ®åº“è¿æ¥
        <span class="cov8" title="1">err = conn.Ping()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("æ•°æ®åº“pingå¤±è´¥: %w", err)
        }</span>

        <span class="cov0" title="0">log.Println("æ•°æ®åº“è¿æ¥æˆåŠŸ")
        return &amp;DB{conn: conn}, nil</span>
}

// Close å…³é—­æ•°æ®åº“è¿æ¥
func (db *DB) Close() error <span class="cov0" title="0">{
        return db.conn.Close()
}</span>

// QueryMetadata æŸ¥è¯¢å…ƒæ•°æ®
func (db *DB) QueryMetadata(req model.ServiceRequest) ([]model.TableMetadata, int64, error) <span class="cov0" title="0">{
        // æ„å»ºæŸ¥è¯¢SQL
        query := "SELECT table_schema, table_name, table_comment, column_name, column_type, column_comment, db_type FROM table_metadata WHERE 1=1"
        var args []interface{}

        // è®°å½•æœç´¢æ¡ä»¶
        searchConditions := []string{}
        if req.Params.TableSchema != "" </span><span class="cov0" title="0">{
                searchConditions = append(searchConditions, fmt.Sprintf("TableSchema: %s", req.Params.TableSchema))
        }</span>
        <span class="cov0" title="0">if req.Params.TableName != "" </span><span class="cov0" title="0">{
                searchConditions = append(searchConditions, fmt.Sprintf("TableName: %s", req.Params.TableName))
        }</span>
        <span class="cov0" title="0">if req.Params.ColumnName != "" </span><span class="cov0" title="0">{
                searchConditions = append(searchConditions, fmt.Sprintf("ColumnName: %s", req.Params.ColumnName))
        }</span>
        <span class="cov0" title="0">if len(searchConditions) &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("ğŸ” æœç´¢æ¡ä»¶: %v", searchConditions)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("ğŸ“œ æŸ¥è¯¢æ‰€æœ‰æ•°æ®ï¼ˆæ— æœç´¢æ¡ä»¶ï¼‰")
        }</span>

        // æ ¹æ®å‚æ•°æ·»åŠ WHEREæ¡ä»¶
        <span class="cov0" title="0">if req.Params.TableSchema != "" </span><span class="cov0" title="0">{
                query += " AND table_schema LIKE ?"
                args = append(args, "%"+req.Params.TableSchema+"%")
        }</span>
        <span class="cov0" title="0">if req.Params.TableName != "" </span><span class="cov0" title="0">{
                query += " AND table_name LIKE ?"
                args = append(args, "%"+req.Params.TableName+"%")
        }</span>
        <span class="cov0" title="0">if req.Params.TableComment != "" </span><span class="cov0" title="0">{
                query += " AND table_comment LIKE ?"
                args = append(args, "%"+req.Params.TableComment+"%")
        }</span>
        <span class="cov0" title="0">if req.Params.ColumnName != "" </span><span class="cov0" title="0">{
                query += " AND column_name LIKE ?"
                args = append(args, "%"+req.Params.ColumnName+"%")
        }</span>
        <span class="cov0" title="0">if req.Params.ColumnType != "" </span><span class="cov0" title="0">{
                query += " AND column_type LIKE ?"
                args = append(args, "%"+req.Params.ColumnType+"%")
        }</span>
        <span class="cov0" title="0">if req.Params.ColumnComment != "" </span><span class="cov0" title="0">{
                query += " AND column_comment LIKE ?"
                args = append(args, "%"+req.Params.ColumnComment+"%")
        }</span>
        <span class="cov0" title="0">if req.Params.DBType != "" </span><span class="cov0" title="0">{
                query += " AND db_type LIKE ?"
                args = append(args, "%"+req.Params.DBType+"%")
        }</span>

        // è·å–æ€»æ•°
        <span class="cov0" title="0">var total int64
        if req.ShowCount == "true" </span><span class="cov0" title="0">{
                countQuery := "SELECT COUNT(*) FROM (" + query + ") AS count_table"
                err := db.conn.QueryRow(countQuery, args...).Scan(&amp;total)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("æŸ¥è¯¢æ€»æ•°å¤±è´¥: %w", err)
                }</span>
                <span class="cov0" title="0">log.Printf("ğŸ“Š æ•°æ®æ€»æ•°: %d", total)</span>
        }

        // æ·»åŠ åˆ†é¡µ
        <span class="cov0" title="0">query += " ORDER BY table_schema, table_name, column_name LIMIT ? OFFSET ?"
        args = append(args, req.Limit, req.Offset)

        // æ‰§è¡ŒæŸ¥è¯¢
        log.Printf("ğŸ—ƒï¸  æ‰§è¡Œæ•°æ®åº“æŸ¥è¯¢...")
        rows, err := db.conn.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("æ•°æ®åº“æŸ¥è¯¢å¤±è´¥: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // å¤„ç†æŸ¥è¯¢ç»“æœ
        var results []model.TableMetadata
        for rows.Next() </span><span class="cov0" title="0">{
                var meta model.TableMetadata
                err := rows.Scan(
                        &amp;meta.TableSchema, &amp;meta.TableName, &amp;meta.TableComment,
                        &amp;meta.ColumnName, &amp;meta.ColumnType, &amp;meta.ColumnComment,
                        &amp;meta.DBType,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("æ•°æ®æ‰«æå¤±è´¥: %w", err)
                }</span>
                <span class="cov0" title="0">results = append(results, meta)</span>
        }

        <span class="cov0" title="0">log.Printf("âœ… æŸ¥è¯¢æˆåŠŸå®Œæˆ - è¿”å›è®°å½•æ•°: %d", len(results))
        if req.ShowCount == "true" </span><span class="cov0" title="0">{
                log.Printf("ğŸ“ˆ æ€»è®°å½•æ•°: %d, å½“å‰é¡µ: %d-%d", total, req.Offset, req.Offset+len(results))
        }</span>

        <span class="cov0" title="0">return results, total, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handler

import (
        "encoding/json"
        "log"
        "net/http"

        "github.com/gin-gonic/gin"

        "httpsserver/internal/auth"
        "httpsserver/internal/database"
        "httpsserver/internal/model"
        "httpsserver/pkg/response"
)

// Handler HTTPå¤„ç†å™¨
type Handler struct {
        db      *database.DB
        authSvc *auth.Service
}

// New åˆ›å»ºæ–°çš„å¤„ç†å™¨
func New(db *database.DB, authSvc *auth.Service) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                db:      db,
                authSvc: authSvc,
        }
}</span>

// HandleServiceRequest å¤„ç†æœåŠ¡è¯·æ±‚
func (h *Handler) HandleServiceRequest(c *gin.Context) <span class="cov0" title="0">{
        serviceId := c.Param("serviceId")

        // è®°å½•è¯·æ±‚è¯¦æƒ…
        log.Printf("ğŸ”µ æ¥æ”¶åˆ°è¯·æ±‚ - ServiceID: %s, ClientIP: %s", serviceId, c.ClientIP())

        var req model.ServiceRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                log.Printf("âŒ è¯·æ±‚å‚æ•°è§£æå¤±è´¥: %v", err)
                errorResponse := response.NewErrorResponse("è¯·æ±‚å‚æ•°æ ¼å¼é”™è¯¯: " + err.Error())

                // æ‰“å°é”™è¯¯è¿”å›å†…å®¹
                if responseJSON, jsonErr := json.Marshal(errorResponse); jsonErr == nil </span><span class="cov0" title="0">{
                        log.Printf("ğŸ“„ é”™è¯¯è¿”å›å†…å®¹: %s", string(responseJSON))
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, errorResponse)
                return</span>
        }

        // è®°å½•è¯·æ±‚å‚æ•°
        <span class="cov0" title="0">log.Printf("ğŸ“‹ è¯·æ±‚å‚æ•° - UserID: %s, ClientID: %s, Offset: %d, Limit: %d",
                req.UserID, req.ClientID, req.Offset, req.Limit)

        // éªŒè¯å®¢æˆ·ç«¯ä¿¡æ¯
        if !h.authSvc.Authenticate(req) </span><span class="cov0" title="0">{
                authErrorResponse := response.NewErrorResponse("å®¢æˆ·ç«¯è®¤è¯å¤±è´¥")

                // æ‰“å°è®¤è¯å¤±è´¥è¿”å›å†…å®¹
                if responseJSON, jsonErr := json.Marshal(authErrorResponse); jsonErr == nil </span><span class="cov0" title="0">{
                        log.Printf("ğŸ“„ è®¤è¯å¤±è´¥è¿”å›å†…å®¹: %s", string(responseJSON))
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusUnauthorized, authErrorResponse)
                return</span>
        }

        // æ ¹æ®serviceIdå¤„ç†ä¸åŒçš„æœåŠ¡
        <span class="cov0" title="0">switch serviceId </span>{
        case "D_A_BSPDMETA":<span class="cov0" title="0">
                h.HandleMetadataQuery(c, req)</span>
        default:<span class="cov0" title="0">
                notFoundResponse := response.NewErrorResponse("æœªæ‰¾åˆ°æŒ‡å®šçš„æœåŠ¡: " + serviceId)
                log.Printf("âŒ æœåŠ¡æœªæ‰¾åˆ° - ServiceID: %s", serviceId)

                // æ‰“å°æœåŠ¡æœªæ‰¾åˆ°è¿”å›å†…å®¹
                if responseJSON, jsonErr := json.Marshal(notFoundResponse); jsonErr == nil </span><span class="cov0" title="0">{
                        log.Printf("ğŸ“„ æœåŠ¡æœªæ‰¾åˆ°è¿”å›å†…å®¹: %s", string(responseJSON))
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusNotFound, notFoundResponse)</span>
        }
}

// HandleMetadataQuery å¤„ç†å…ƒæ•°æ®æŸ¥è¯¢
func (h *Handler) HandleMetadataQuery(c *gin.Context, req model.ServiceRequest) <span class="cov0" title="0">{
        log.Printf("ğŸ” å¼€å§‹å¤„ç†å…ƒæ•°æ®æŸ¥è¯¢è¯·æ±‚")

        // æŸ¥è¯¢æ•°æ®åº“
        results, total, err := h.db.QueryMetadata(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("âŒ æ•°æ®åº“æŸ¥è¯¢å¤±è´¥: %v", err)
                errorResponse := response.NewErrorResponse("æ•°æ®åº“æŸ¥è¯¢å¤±è´¥: " + err.Error())

                // æ‰“å°æ•°æ®åº“æŸ¥è¯¢å¤±è´¥è¿”å›å†…å®¹
                if responseJSON, jsonErr := json.Marshal(errorResponse); jsonErr == nil </span><span class="cov0" title="0">{
                        log.Printf("ğŸ“„ æ•°æ®åº“æŸ¥è¯¢å¤±è´¥è¿”å›å†…å®¹: %s", string(responseJSON))
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, errorResponse)
                return</span>
        }

        // æ„å»ºå“åº”
        <span class="cov0" title="0">var resp response.ServiceResponse
        if req.ShowCount == "true" </span><span class="cov0" title="0">{
                resp = response.NewSuccessResponseWithTotal(results, total)
        }</span> else<span class="cov0" title="0"> {
                resp = response.NewSuccessResponse(results)
        }</span>

        // æ‰“å°è¯¦ç»†çš„è¿”å›æ•°æ®å†…å®¹
        <span class="cov0" title="0">responseJSON, err := json.Marshal(resp)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("âŒ JSONåºåˆ—åŒ–å¤±è´¥: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("ğŸ“„ è¿”å›æ•°æ®å†…å®¹:")
                log.Printf("%s", string(responseJSON))
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, resp)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package utils

import (
        "log"
        "net/http"
        "os"
)

// GenerateSelfSignedCert ç”Ÿæˆè‡ªç­¾åè¯ä¹¦
func GenerateSelfSignedCert(certFile, keyFile string) <span class="cov8" title="1">{
        // æ£€æŸ¥è¯ä¹¦æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if FileExists(certFile) &amp;&amp; FileExists(keyFile) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">log.Println("ç”Ÿæˆè‡ªç­¾åSSLè¯ä¹¦...")

        // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…ç”Ÿäº§ç¯å¢ƒåº”è¯¥ä½¿ç”¨çœŸå®è¯ä¹¦
        // æ‚¨å¯ä»¥ä½¿ç”¨opensslå‘½ä»¤ç”Ÿæˆï¼š
        // openssl req -x509 -newkey rsa:4096 -keyout server.key -out server.crt -days 365 -nodes -subj "/CN=localhost"

        log.Printf("è¯·æ‰‹åŠ¨ç”ŸæˆSSLè¯ä¹¦æ–‡ä»¶:")
        log.Printf("openssl req -x509 -newkey rsa:4096 -keyout %s -out %s -days 365 -nodes -subj \"/CN=localhost\"", keyFile, certFile)
        log.Fatal("SSLè¯ä¹¦æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¯·å…ˆç”Ÿæˆè¯ä¹¦æ–‡ä»¶")</span>
}

// FileExists æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
func FileExists(filename string) bool <span class="cov8" title="1">{
        _, err := os.Stat(filename)
        return err == nil
}</span>

// FileExistsOld æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼ˆæ—§ç‰ˆæœ¬æ–¹æ³•ï¼‰
func FileExistsOld(filename string) bool <span class="cov8" title="1">{
        _, err := http.Dir(".").Open(filename)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "log"
        "net/http"

        "github.com/gin-gonic/gin"
        _ "github.com/go-sql-driver/mysql"
)

// è¯·æ±‚ç»“æ„ä½“
type ServiceRequest struct {
        Params struct {
                ColumnComment string `json:"columnComment"`
                ColumnType    string `json:"columnType"`
                ColumnName    string `json:"columnName"`
                TableComment  string `json:"tableComment"`
                TableName     string `json:"tableName"`
                TableSchema   string `json:"tableSchema"`
                DBType        string `json:"dbType"`
        } `json:"params"`
        ServiceID    string `json:"serviceId"`
        ShowCount    string `json:"showCount"`
        Offset       int    `json:"offset"`
        Limit        int    `json:"limit"`
        UserID       string `json:"userId"`
        ClientID     string `json:"clientId"`
        ClientSecret string `json:"clientSecret"`
}

// å“åº”ç»“æ„ä½“
type ServiceResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data"`
        Total   int64       `json:"total,omitempty"`
        Message string      `json:"message,omitempty"`
}

// æ•°æ®åº“è¡¨ç»“æ„ä¿¡æ¯
type TableMetadata struct {
        TableSchema   string `json:"tableSchema"`
        TableName     string `json:"tableName"`
        TableComment  string `json:"tableComment"`
        ColumnName    string `json:"columnName"`
        ColumnType    string `json:"columnType"`
        ColumnComment string `json:"columnComment"`
        DBType        string `json:"dbType"`
}

var db *sql.DB
var config *Config

func main() <span class="cov0" title="0">{
        // åŠ è½½é…ç½®
        config = getConfig()

        // åˆå§‹åŒ–æ•°æ®åº“è¿æ¥
        initDB()
        defer db.Close()

        // è®¾ç½®Ginä¸ºå‘å¸ƒæ¨¡å¼
        gin.SetMode(gin.ReleaseMode)

        // åˆ›å»ºGinå¼•æ“
        r := gin.Default()

        // æ·»åŠ è¯·æ±‚æ—¥å¿—è®°å½•ä¸­é—´ä»¶
        r.Use(gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string </span><span class="cov0" title="0">{
                return fmt.Sprintf("[%s] %s \"%s %s %s\" %d %s \"%s\" \"%s\" %d\n",
                        param.TimeStamp.Format("2006/01/02 - 15:04:05"),
                        param.ClientIP,
                        param.Method,
                        param.Path,
                        param.Request.Proto,
                        param.StatusCode,
                        param.Latency,
                        param.Request.UserAgent(),
                        param.ErrorMessage,
                        param.BodySize,
                )
        }</span>))

        // æ·»åŠ CORSä¸­é—´ä»¶
        <span class="cov0" title="0">r.Use(func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("Access-Control-Allow-Origin", "*")
                c.Header("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE")
                c.Header("Access-Control-Allow-Headers", "Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        })

        // å®šä¹‰è·¯ç”±
        <span class="cov0" title="0">r.POST("/service/:serviceId", handleServiceRequest)

        // ç”Ÿæˆè‡ªç­¾åè¯ä¹¦ï¼ˆä»…ç”¨äºå¼€å‘æµ‹è¯•ï¼‰
        generateSelfSignedCert()

        // å¯åŠ¨HTTPSæœåŠ¡å™¨
        log.Printf("HTTPSæœåŠ¡å™¨å¯åŠ¨åœ¨ç«¯å£%s...", config.Server.Port)
        log.Fatal(r.RunTLS(":"+config.Server.Port, config.Server.CertFile, config.Server.KeyFile))</span>
}

func initDB() <span class="cov0" title="0">{
        var err error
        // è¿æ¥MySQLæ•°æ®åº“
        dsn := config.GetDSN()
        db, err = sql.Open("mysql", dsn)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("æ•°æ®åº“è¿æ¥å¤±è´¥:", err)
        }</span>

        // æµ‹è¯•æ•°æ®åº“è¿æ¥
        <span class="cov0" title="0">err = db.Ping()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("æ•°æ®åº“pingå¤±è´¥:", err)
        }</span>

        <span class="cov0" title="0">log.Println("æ•°æ®åº“è¿æ¥æˆåŠŸ")</span>
}

func handleServiceRequest(c *gin.Context) <span class="cov0" title="0">{
        serviceId := c.Param("serviceId")

        // è®°å½•è¯·æ±‚è¯¦æƒ…
        log.Printf("ğŸ”µ æ¥æ”¶åˆ°è¯·æ±‚ - ServiceID: %s, ClientIP: %s", serviceId, c.ClientIP())

        var req ServiceRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                log.Printf("âŒ è¯·æ±‚å‚æ•°è§£æå¤±è´¥: %v", err)
                errorResponse := ServiceResponse{
                        Success: false,
                        Message: "è¯·æ±‚å‚æ•°æ ¼å¼é”™è¯¯: " + err.Error(),
                }
                // æ‰“å°é”™è¯¯è¿”å›å†…å®¹
                if responseJSON, jsonErr := json.Marshal(errorResponse); jsonErr == nil </span><span class="cov0" title="0">{
                        log.Printf("ğŸ“„ é”™è¯¯è¿”å›å†…å®¹: %s", string(responseJSON))
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, errorResponse)
                return</span>
        }

        // è®°å½•è¯·æ±‚å‚æ•°
        <span class="cov0" title="0">log.Printf("ğŸ“‹ è¯·æ±‚å‚æ•° - UserID: %s, ClientID: %s, Offset: %d, Limit: %d",
                req.UserID, req.ClientID, req.Offset, req.Limit)

        // éªŒè¯å®¢æˆ·ç«¯ä¿¡æ¯
        if req.ClientID != config.Auth.ClientID || req.ClientSecret != config.Auth.ClientSecret </span><span class="cov0" title="0">{
                log.Printf("ğŸš« å®¢æˆ·ç«¯è®¤è¯å¤±è´¥ - ClientID: %s", req.ClientID)
                authErrorResponse := ServiceResponse{
                        Success: false,
                        Message: "å®¢æˆ·ç«¯è®¤è¯å¤±è´¥",
                }
                // æ‰“å°è®¤è¯å¤±è´¥è¿”å›å†…å®¹
                if responseJSON, jsonErr := json.Marshal(authErrorResponse); jsonErr == nil </span><span class="cov0" title="0">{
                        log.Printf("ğŸ“„ è®¤è¯å¤±è´¥è¿”å›å†…å®¹: %s", string(responseJSON))
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusUnauthorized, authErrorResponse)
                return</span>
        }

        <span class="cov0" title="0">log.Printf("âœ… å®¢æˆ·ç«¯è®¤è¯æˆåŠŸ - UserID: %s", req.UserID)

        // æ ¹æ®serviceIdå¤„ç†ä¸åŒçš„æœåŠ¡
        switch serviceId </span>{
        case "D_A_BSPDMETA":<span class="cov0" title="0">
                handleMetadataQuery(c, req)</span>
        default:<span class="cov0" title="0">
                notFoundResponse := ServiceResponse{
                        Success: false,
                        Message: "æœªæ‰¾åˆ°æŒ‡å®šçš„æœåŠ¡: " + serviceId,
                }
                log.Printf("âŒ æœåŠ¡æœªæ‰¾åˆ° - ServiceID: %s", serviceId)
                // æ‰“å°æœåŠ¡æœªæ‰¾åˆ°è¿”å›å†…å®¹
                if responseJSON, jsonErr := json.Marshal(notFoundResponse); jsonErr == nil </span><span class="cov0" title="0">{
                        log.Printf("ğŸ“„ æœåŠ¡æœªæ‰¾åˆ°è¿”å›å†…å®¹: %s", string(responseJSON))
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusNotFound, notFoundResponse)</span>
        }
}

func handleMetadataQuery(c *gin.Context, req ServiceRequest) <span class="cov0" title="0">{
        log.Printf("ğŸ” å¼€å§‹å¤„ç†å…ƒæ•°æ®æŸ¥è¯¢è¯·æ±‚")

        // æ„å»ºæŸ¥è¯¢SQL
        query := "SELECT table_schema, table_name, table_comment, column_name, column_type, column_comment, db_type FROM table_metadata WHERE 1=1"
        var args []interface{}

        // è®°å½•æœç´¢æ¡ä»¶
        searchConditions := []string{}
        if req.Params.TableSchema != "" </span><span class="cov0" title="0">{
                searchConditions = append(searchConditions, fmt.Sprintf("TableSchema: %s", req.Params.TableSchema))
        }</span>
        <span class="cov0" title="0">if req.Params.TableName != "" </span><span class="cov0" title="0">{
                searchConditions = append(searchConditions, fmt.Sprintf("TableName: %s", req.Params.TableName))
        }</span>
        <span class="cov0" title="0">if req.Params.ColumnName != "" </span><span class="cov0" title="0">{
                searchConditions = append(searchConditions, fmt.Sprintf("ColumnName: %s", req.Params.ColumnName))
        }</span>
        <span class="cov0" title="0">if len(searchConditions) &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("ğŸ” æœç´¢æ¡ä»¶: %v", searchConditions)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("ğŸ“œ æŸ¥è¯¢æ‰€æœ‰æ•°æ®ï¼ˆæ— æœç´¢æ¡ä»¶ï¼‰")
        }</span>

        // æ ¹æ®å‚æ•°æ·»åŠ WHEREæ¡ä»¶
        <span class="cov0" title="0">if req.Params.TableSchema != "" </span><span class="cov0" title="0">{
                query += " AND table_schema LIKE ?"
                args = append(args, "%"+req.Params.TableSchema+"%")
        }</span>
        <span class="cov0" title="0">if req.Params.TableName != "" </span><span class="cov0" title="0">{
                query += " AND table_name LIKE ?"
                args = append(args, "%"+req.Params.TableName+"%")
        }</span>
        <span class="cov0" title="0">if req.Params.TableComment != "" </span><span class="cov0" title="0">{
                query += " AND table_comment LIKE ?"
                args = append(args, "%"+req.Params.TableComment+"%")
        }</span>
        <span class="cov0" title="0">if req.Params.ColumnName != "" </span><span class="cov0" title="0">{
                query += " AND column_name LIKE ?"
                args = append(args, "%"+req.Params.ColumnName+"%")
        }</span>
        <span class="cov0" title="0">if req.Params.ColumnType != "" </span><span class="cov0" title="0">{
                query += " AND column_type LIKE ?"
                args = append(args, "%"+req.Params.ColumnType+"%")
        }</span>
        <span class="cov0" title="0">if req.Params.ColumnComment != "" </span><span class="cov0" title="0">{
                query += " AND column_comment LIKE ?"
                args = append(args, "%"+req.Params.ColumnComment+"%")
        }</span>
        <span class="cov0" title="0">if req.Params.DBType != "" </span><span class="cov0" title="0">{
                query += " AND db_type LIKE ?"
                args = append(args, "%"+req.Params.DBType+"%")
        }</span>

        // è·å–æ€»æ•°
        <span class="cov0" title="0">var total int64
        if req.ShowCount == "true" </span><span class="cov0" title="0">{
                countQuery := "SELECT COUNT(*) FROM (" + query + ") AS count_table"
                err := db.QueryRow(countQuery, args...).Scan(&amp;total)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("âŒ æŸ¥è¯¢æ€»æ•°å¤±è´¥: %v", err)
                        countErrorResponse := ServiceResponse{
                                Success: false,
                                Message: "æŸ¥è¯¢æ€»æ•°å¤±è´¥: " + err.Error(),
                        }
                        // æ‰“å°æŸ¥è¯¢æ€»æ•°å¤±è´¥è¿”å›å†…å®¹
                        if responseJSON, jsonErr := json.Marshal(countErrorResponse); jsonErr == nil </span><span class="cov0" title="0">{
                                log.Printf("ğŸ“„ æŸ¥è¯¢æ€»æ•°å¤±è´¥è¿”å›å†…å®¹: %s", string(responseJSON))
                        }</span>
                        <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, countErrorResponse)
                        return</span>
                }
                <span class="cov0" title="0">log.Printf("ğŸ“Š æ•°æ®æ€»æ•°: %d", total)</span>
        }

        // æ·»åŠ åˆ†é¡µ
        <span class="cov0" title="0">query += " ORDER BY table_schema, table_name, column_name LIMIT ? OFFSET ?"
        args = append(args, req.Limit, req.Offset)

        // æ‰§è¡ŒæŸ¥è¯¢
        log.Printf("ğŸ—ƒï¸  æ‰§è¡Œæ•°æ®åº“æŸ¥è¯¢...")
        rows, err := db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("âŒ æ•°æ®åº“æŸ¥è¯¢å¤±è´¥: %v", err)
                queryErrorResponse := ServiceResponse{
                        Success: false,
                        Message: "æ•°æ®åº“æŸ¥è¯¢å¤±è´¥: " + err.Error(),
                }
                // æ‰“å°æ•°æ®åº“æŸ¥è¯¢å¤±è´¥è¿”å›å†…å®¹
                if responseJSON, jsonErr := json.Marshal(queryErrorResponse); jsonErr == nil </span><span class="cov0" title="0">{
                        log.Printf("ğŸ“„ æ•°æ®åº“æŸ¥è¯¢å¤±è´¥è¿”å›å†…å®¹: %s", string(responseJSON))
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, queryErrorResponse)
                return</span>
        }
        <span class="cov0" title="0">defer rows.Close()

        // å¤„ç†æŸ¥è¯¢ç»“æœ
        var results []TableMetadata
        for rows.Next() </span><span class="cov0" title="0">{
                var meta TableMetadata
                err := rows.Scan(
                        &amp;meta.TableSchema, &amp;meta.TableName, &amp;meta.TableComment,
                        &amp;meta.ColumnName, &amp;meta.ColumnType, &amp;meta.ColumnComment,
                        &amp;meta.DBType,
                )
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("âŒ æ•°æ®æ‰«æå¤±è´¥: %v", err)
                        scanErrorResponse := ServiceResponse{
                                Success: false,
                                Message: "æ•°æ®æ‰«æå¤±è´¥: " + err.Error(),
                        }
                        // æ‰“å°æ•°æ®æ‰«æå¤±è´¥è¿”å›å†…å®¹
                        if responseJSON, jsonErr := json.Marshal(scanErrorResponse); jsonErr == nil </span><span class="cov0" title="0">{
                                log.Printf("ğŸ“„ æ•°æ®æ‰«æå¤±è´¥è¿”å›å†…å®¹: %s", string(responseJSON))
                        }</span>
                        <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, scanErrorResponse)
                        return</span>
                }
                <span class="cov0" title="0">results = append(results, meta)</span>
        }

        // æ„å»ºå“åº”
        <span class="cov0" title="0">response := ServiceResponse{
                Success: true,
                Data:    results,
        }

        if req.ShowCount == "true" </span><span class="cov0" title="0">{
                response.Total = total
        }</span>

        <span class="cov0" title="0">log.Printf("âœ… æŸ¥è¯¢æˆåŠŸå®Œæˆ - è¿”å›è®°å½•æ•°: %d", len(results))
        if req.ShowCount == "true" </span><span class="cov0" title="0">{
                log.Printf("ğŸ“ˆ æ€»è®°å½•æ•°: %d, å½“å‰é¡µ: %d-%d", total, req.Offset, req.Offset+len(results))
        }</span>

        // æ‰“å°è¯¦ç»†çš„è¿”å›æ•°æ®å†…å®¹
        <span class="cov0" title="0">responseJSON, err := json.Marshal(response)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("âŒ JSONåºåˆ—åŒ–å¤±è´¥: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("ğŸ“„ è¿”å›æ•°æ®å†…å®¹:")
                log.Printf("%s", string(responseJSON))
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

func generateSelfSignedCert() <span class="cov0" title="0">{
        // æ£€æŸ¥è¯ä¹¦æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if fileExists(config.Server.CertFile) &amp;&amp; fileExists(config.Server.KeyFile) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">log.Println("ç”Ÿæˆè‡ªç­¾åSSLè¯ä¹¦...")

        // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…ç”Ÿäº§ç¯å¢ƒåº”è¯¥ä½¿ç”¨çœŸå®è¯ä¹¦
        // æ‚¨å¯ä»¥ä½¿ç”¨opensslå‘½ä»¤ç”Ÿæˆï¼š
        // openssl req -x509 -newkey rsa:4096 -keyout server.key -out server.crt -days 365 -nodes -subj "/CN=localhost"

        log.Printf("è¯·æ‰‹åŠ¨ç”ŸæˆSSLè¯ä¹¦æ–‡ä»¶:")
        log.Printf("openssl req -x509 -newkey rsa:4096 -keyout %s -out %s -days 365 -nodes -subj \"/CN=localhost\"", config.Server.KeyFile, config.Server.CertFile)
        log.Fatal("SSLè¯ä¹¦æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¯·å…ˆç”Ÿæˆè¯ä¹¦æ–‡ä»¶")</span>
}

func fileExists(filename string) bool <span class="cov0" title="0">{
        _, err := http.Dir(".").Open(filename)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package response

// ServiceResponse æœåŠ¡å“åº”ç»“æ„ä½“
type ServiceResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data"`
        Total   int64       `json:"total,omitempty"`
        Message string      `json:"message,omitempty"`
}

// NewSuccessResponse åˆ›å»ºæˆåŠŸå“åº”
func NewSuccessResponse(data interface{}) ServiceResponse <span class="cov8" title="1">{
        return ServiceResponse{
                Success: true,
                Data:    data,
        }
}</span>

// NewSuccessResponseWithTotal åˆ›å»ºå¸¦æ€»æ•°çš„æˆåŠŸå“åº”
func NewSuccessResponseWithTotal(data interface{}, total int64) ServiceResponse <span class="cov8" title="1">{
        return ServiceResponse{
                Success: true,
                Data:    data,
                Total:   total,
        }
}</span>

// NewErrorResponse åˆ›å»ºé”™è¯¯å“åº”
func NewErrorResponse(message string) ServiceResponse <span class="cov8" title="1">{
        return ServiceResponse{
                Success: false,
                Message: message,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
